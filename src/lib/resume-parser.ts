/**
 * Resume Parser Service
 *
 * This file contains a dummy resume parser that extracts mock data.
 * In production, this would integrate with AI services or n8n workflows
 * for actual resume parsing and data extraction.
 *
 * TODO: Replace with actual AI-powered resume parsing
 * - Integrate with OpenAI/Claude for text extraction
 * - Use n8n workflow for document processing
 * - Connect to resume parsing API (e.g., Affinda, Sovren)
 */

// Sample data for mock parsing
const SAMPLE_SKILLS = [
  "JavaScript",
  "TypeScript",
  "React",
  "Node.js",
  "Python",
  "Java",
  "SQL",
  "AWS",
  "Docker",
  "Kubernetes",
  "GraphQL",
  "REST API",
  "MongoDB",
  "PostgreSQL",
  "Redis",
  "Git",
  "CI/CD",
  "Agile",
  "Scrum",
  "TDD",
  "Machine Learning",
  "Data Analysis",
  "Excel",
  "Communication",
  "Leadership",
  "Project Management",
  "Problem Solving",
];

const SAMPLE_ROLES = [
  "Software Engineer",
  "Frontend Developer",
  "Backend Developer",
  "Full Stack Developer",
  "DevOps Engineer",
  "Data Scientist",
  "Product Manager",
  "UX Designer",
  "QA Engineer",
  "Technical Lead",
  "Engineering Manager",
  "Solutions Architect",
];

export interface ParsedResume {
  candidateName: string;
  skills: string[];
  experienceYears: number;
  atsScore: number;
  aiReasoning: string;
}

/**
 * Extracts candidate name from filename
 * Attempts to parse common resume naming patterns
 */
function extractNameFromFilename(filename: string): string {
  // Remove file extension
  const nameWithoutExt = filename.replace(/\.(pdf|docx?|txt)$/i, "");

  // Common patterns: "John_Doe_Resume", "Resume_John_Doe", "JohnDoe_CV"
  const cleanedName = nameWithoutExt
    .replace(/(resume|cv|curriculum[\s_-]?vitae)/gi, "")
    .replace(/[_-]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  // If we have something reasonable, use it
  if (cleanedName.length > 2) {
    // Capitalize each word
    return cleanedName
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(" ");
  }

  // Fallback to a generated name
  const firstNames = [
    "Alex",
    "Jordan",
    "Taylor",
    "Morgan",
    "Casey",
    "Riley",
    "Quinn",
    "Avery",
  ];
  const lastNames = [
    "Smith",
    "Johnson",
    "Williams",
    "Brown",
    "Jones",
    "Garcia",
    "Miller",
    "Davis",
  ];

  return `${firstNames[Math.floor(Math.random() * firstNames.length)]} ${lastNames[Math.floor(Math.random() * lastNames.length)]}`;
}

/**
 * Generates random skills from the sample list
 */
function generateRandomSkills(): string[] {
  const numSkills = Math.floor(Math.random() * 5) + 4; // 4-8 skills
  const shuffled = [...SAMPLE_SKILLS].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, numSkills);
}

/**
 * Generates a random experience level
 */
function generateRandomExperience(): number {
  return Math.floor(Math.random() * 12) + 1; // 1-12 years
}

/**
 * Generates a random ATS score
 * Higher scores are less common to simulate realistic distribution
 */
function generateATSScore(): number {
  // Weighted random: more candidates in 60-80 range
  const base = Math.random();
  if (base < 0.1) return Math.floor(Math.random() * 20) + 40; // 40-60 (10%)
  if (base < 0.6) return Math.floor(Math.random() * 20) + 60; // 60-80 (50%)
  if (base < 0.9) return Math.floor(Math.random() * 15) + 80; // 80-95 (30%)
  return Math.floor(Math.random() * 5) + 95; // 95-100 (10%)
}

/**
 * Generates AI reasoning based on the parsed data
 */
function generateAIReasoning(
  skills: string[],
  experience: number,
  score: number,
): string {
  const role = SAMPLE_ROLES[Math.floor(Math.random() * SAMPLE_ROLES.length)];

  const reasoningParts = [
    `This candidate appears to be an experienced ${role} with ${experience} years of experience.`,
    `Key strengths include proficiency in ${skills.slice(0, 3).join(", ")}.`,
  ];

  if (score >= 85) {
    reasoningParts.push(
      "Strong alignment with typical job requirements. Recommended for immediate interview.",
    );
  } else if (score >= 70) {
    reasoningParts.push(
      "Good overall fit with some areas for further evaluation during interview.",
    );
  } else {
    reasoningParts.push(
      "May require additional screening to assess fit for the role.",
    );
  }

  reasoningParts.push(
    `\n\nNote: This is a demo analysis. In production, this would be generated by AI based on actual resume content and job description matching.`,
  );

  return reasoningParts.join(" ");
}

/**
 * Parses a resume file and extracts candidate information
 *
 * TODO: Integrate with actual parsing service
 * - Use document parsing library for text extraction
 * - Send to AI for structured data extraction
 * - Match against job descriptions for scoring
 *
 * @param filename - The name of the uploaded file
 * @param _fileBuffer - The file buffer (unused in mock implementation)
 */
export async function parseResume(
  filename: string,
  _fileBuffer?: Buffer,
): Promise<ParsedResume> {
  // Simulate processing delay
  await new Promise((resolve) => setTimeout(resolve, 500));

  const candidateName = extractNameFromFilename(filename);
  const skills = generateRandomSkills();
  const experienceYears = generateRandomExperience();
  const atsScore = generateATSScore();
  const aiReasoning = generateAIReasoning(skills, experienceYears, atsScore);

  console.log(
    `[Resume Parser] Parsed "${filename}" for candidate: ${candidateName}`,
  );

  return {
    candidateName,
    skills,
    experienceYears,
    atsScore,
    aiReasoning,
  };
}

/**
 * Validates if a file is an acceptable resume format
 */
export function isValidResumeFormat(filename: string): boolean {
  const validExtensions = [".pdf", ".doc", ".docx", ".txt"];
  const dotIndex = filename.lastIndexOf(".");

  // If no extension found, return false
  if (dotIndex === -1) return false;

  const ext = filename.toLowerCase().slice(dotIndex);
  return validExtensions.includes(ext);
}

/**
 * Gets the MIME type for a resume file
 */
export function getResumeMimeType(filename: string): string {
  const dotIndex = filename.lastIndexOf(".");

  // If no extension found, return default
  if (dotIndex === -1) return "application/octet-stream";

  const ext = filename.toLowerCase().slice(dotIndex);
  const mimeTypes: Record<string, string> = {
    ".pdf": "application/pdf",
    ".doc": "application/msword",
    ".docx":
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".txt": "text/plain",
  };
  return mimeTypes[ext] || "application/octet-stream";
}

/**
 * Validates if a file's MIME type is acceptable
 */
export function isValidMimeType(mimeType: string): boolean {
  const validMimeTypes = [
    "application/pdf",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "text/plain",
  ];
  return validMimeTypes.includes(mimeType);
}
